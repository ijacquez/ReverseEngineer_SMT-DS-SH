--------------------------------------------------------------------------------
Symbols:

_fontdata
_fontnext
_STR_stat
_STR_bgclear
_FontImage
_Font_Init
_pFontPos
_Font_Window_Process
_hiragana_String

--------------------------------------------------------------------------------
Strings found in file "0" (potentional offsets):

9_LOAD.BIN
File "0"
found a match at: 0x00018918


9_TITLE.BIN
File "0"
found a match at: 0x000187c8


A_OP.BIN
File "0"
found a match at: 0x00018930


A_TITLE.BIN
File "0"
found a match at: 0x00018948


DGB_MAP.BIN
File "0"
found a match at: 0x00018960


DGC_CMP.BIN
File "0"
found a match at: 0x000188b8
File "DGN_3DD.BIN"
found a match at: 0x0000ae60


DGN_3DD.BIN
File "0"
found a match at: 0x000187f8
File "DGC_CMP.BIN"
found a match at: 0x000007d0
File "DVL_BAT1.BIN"
found a match at: 0x00059cc4


DVL_BAT1.BIN
File "0"
found a match at: 0x00018810
File "DGN_3DD.BIN"
found a match at: 0x0000d93c


DZ_ST.BIN
File "0"
found a match at: 0x000188e8
found a match at: 0x00018990
File "DVL_BAT1.BIN"
found a match at: 0x00059cd4


EQ.BIN
File "0"
found a match at: 0x00018978


EVE_MAIN.BIN
File "0"
found a match at: 0x00018870


EVE_NAME.BIN
File "0"
found a match at: 0x00018900


EVE_SAVE.BIN
File "0"
found a match at: 0x000188d0


EVE_TM.BIN
File "0"
found a match at: 0x00018888


GOMADEN.BIN
File "0"
found a match at: 0x00018840
File "M00_2D.BIN"
found a match at: 0x0000cd60


INS.BIN
File "0"
found a match at: 0x00018858
found a match at: 0x000189d8
File "M00_2D.BIN"
found a match at: 0x000038ec
found a match at: 0x0000c5d8


INST.BIN
File "0"
found a match at: 0x000189a8


KYU_PET.BIN
File "0"
found a match at: 0x000189c0


M00_2D.BIN
File "0"
found a match at: 0x000187e0
File "GOMADEN.BIN"
found a match at: 0x00006de0


Z_ENDMOV.BIN
File "0"
found a match at: 0x000188a0


Z_GRAPH.BIN
File "0"
found a match at: 0x00018828

--------------------------------------------------------------------------------
EVE_TM.BIN seems to handle everything with events

2-word pattern name data:
0x05E41400 => 0x000035C4, 0x000035C6
0x05E41500 => 0x00003674, 0x0000367C

First character(s) are stored in:
0x05E00000 | (0x3500 << 5) = 0x05E6A000
0x05E00000 | (0x3548 << 5) = 0x05E6A900
0x05E00000 | (0x35C4 << 5) = 0x05E6B880

! Invokes 0x06032270()
0x060327CC:

! Writing routine
0x06032270:

! Copies from CS2 area to LWRAM
0x0600A854:

! Called by 0x0600A854():
0x0600AA40:

! Seems to clear actual pattern data
0x06030EB4:

A_FONT16.BIN is copied to 0x00200000, but the first 0x80 bytes are zeroed out

/* Offsets into the font and unpacks 1BPP to 8BPP
 * And writes uncompressed font at 0x060566B0
 * Then writes to VRAM */
void _06031354(uint16_t val, uint16_t val2, uint16_t converted_val, uint16_t index) {
        /* r9 = val,
         * r8 = val2
         * r10 = r6
         */
        val &= 0xFFFF;
        val2 &= 0xFFFF;
        uint16_t val3 = val2;

        if ((converted_val & converted_val) == 0) {
                /* @ 0x06031376 */
        } else {
                /* @ 0x06031382 */
                if (val > 0x24) {
                        /* @ 0x0603138A */
                        return;
                } else {
                        /* @ 0x0603138E */
                        if (val2 > 0x1A) {
                                /* @ 0x06031394 */
                        } else {
                                /* @ 0x060313A2 */
                                val = val + (((0x26 * val2) + 0x10) << 6) + 0x25E60000;
                                uint8_t *valb = (uint8_t *)(*(uint32_t *)0x060314A8) + index;
                                /* On stack */
                                uint16_t new_var = ((*valb & 0xFF) + 0x08) & 0xFFFF;
                                if (converted_val > 0x13F) {
                                        /* @ 0x060313CC */
                                } else {
                                        /* @ 0x060314C0 */
                                        /* memset((void *)0x060566B8, 0, 0x100); */

                                        uint32_t addr1 = 0x060566B8;
                                        uint32_t copy_index = index;
                                        while (true) {
                                                *(uint32_t *)addr1 = 0x00000000;
                                                addr1 += 4;
                                                copy_index++;
                                                if (copy_index > 0x3F) {
                                                        goto _0x060313E0;
                                                } else {
                                                        /* @ 0x060313D2 */
                                                }
                                        }

                                _0x060313E0:
                                        uint16_t *font_addr = 0x00200000 + (converted_val << 5);
                                        uint32_t addr2 = 0x060576C0;

                                        uint32_t copy_index = index;
                                _0x060313F2:
                                        uint16_t fontdata = *font_addr++ & 0xFFFF;
                                        copy_index <<= 4;
                                        uint32_t addr3 = 0x060566C9 + copy_index;
                                        uint32_t new_var2 = 0x00000000; /* r14 + 0x4 */

                                _0x06031404:
                                        uint16_t fontdata_ord = fontdata & 0x8000;
                                        if ((fontdata_ord & fontdata_ord) == 0) {
                                                /* @ 0x06031426 */
                                                fontdata <<= 1;
                                                if (new_var2++ > 0x0E) {
                                                        goto _0x06031436;
                                                } else {
                                                        /* @ 0x06031404 */
                                                        goto _0x06031404;
                                                }
                                        } else {
                                                /* @ 0x06031410 */
                                                new_var2 += copy_index;
                                                r2 = *(uint32_t *)addr2;
                                        }
                                _0x06031436:
                                        if ((index + 1) > 0x0E) {
                                                /* @ 0x06031440 */
                                        } else {
                                                index++;
                                                goto _0x060313F2;
                                        }
                                }
                        }
                }
        }
}

/* Converts character value to actual index number */
static uint32_t *text_start = NULL;
int _routine_0x06032270(index, ?, addr) {
        uint8_t *text = (uint8_t *)(*(uint32_t *)(0x06032520 + (index << 2)));
        uint8_t hbyte = *text & 0xFF; /* r3 */

        if (hbyte == 0x00)
                return 0;

        if (hbyte > 0x7F) {
                /* @ 0x0603234C */
                if (hbyte != 0xFF) {
                        /* @ 0x060323A8 */
                        if ((hbyte & 0xF0) == 0xF0) {
                                /* @ XXX 0x060323B4 */
                        } else {
                                if ((hbyte & 0xE0) == 0xE0) {
                                /* @ XXX 0x060323C6 */
                                } else {
                                        /* @ 0x06032444 */
                                        uint16_t *val = (uint16_t *)(*(uint32_t *)(0x0603250C + (index << 1)));
                                        if ((*val & 0xFFFF) > 0x0022) {
                                                /* @ 0x06032456 */
                                        } else {
                                                /* @ 0x06032470 */
                                                if (*val > 0x0023) {
                                                        /* @ 0x06032484 */
                                                } else {
                                                        /* @ 0x0603249C */
                                                        uint16_t *val2 = (uint16_t *)(*(uint32_t *)(0x06032510 + (index << 1)));
                                                        if ((*val2 & 0xFFFF) > 0x0018) {
                                                                /* 0x060324AE */
                                                        } else {
                                                                /* @ 0x060324B8 */
                                                                uint16_t new_hbyte = (hbyte & 0x3F) << 6;
                                                                *(uint16_t *)(0x06032520 + (index << 2)) = ++text;
                                                                uint8_t lbyte = *text;
                                                                lbyte &= 0x7F;
                                                                new_hbyte += lbyte & 0x7F;
                                                                *(uint16_t *)(0x06032520 + (index << 2)) = ++text;

                                                                _06031354(*val, *val2, new_hbyte, index << 1);
                                                        }
                                                }
                                        }
                                }
                        }
                } else {
                        /* @ 0x06032354 */
                }
        } else {
                /* @ 0x060322A4 - 0x0603234A */
        }
}
--------------------------------------------------------------------------------
Executable VWF DVL_BAT1.BIN

The "D_EXTRA.EVE" is loaded
The entire EVE_TM.BIN file is loaded at 0x06030000-0x06060730
The entire DVL_BAT1.BIN file is loaded at 0x06030000-0x0609723C
When selecting "FIGHT", first character in VRAM is in 0x05E60DC0

Routine 0x0606B2A0 -
Routine 0x0606B940 -
Routine 0x0606B490 -
Routine 0x0606B540 -

Routine 0x06058576 - Calls 0x06067EAC

Routine 0x06067EAC - Calls 0x06067BC8
                   - Calls 0x06065DEC
                   - Calls 0x06067E18

Routine 0x06067BC8 -

Routine 0x06065DEC - Important!
                   - Returns the start of a string from a table of offsets

Routine 0x06067E18 - Allocates 128 bytes on stack (64 characters)
                   - Reads from the list of strings below and writes to stack
                   - Calls 0x06067C78

Routine 0x06067C78 - Calls 0x0606BA70

Routine 0x0606BA70 - Takes 3 arguments, last one is stack addr
                   - Calls 0x0606A570

Routine 0x0606A570 - Writes yen amount
Routine 0x0606AFEC - Hm... reads in 0x060FFA84, pointer stored in 0x0609B530
Routine 0x0606A0CC - Writes to VRAM 060B6CE0

Strings found

0x060935E4 ?

Tables

0x0608EC34-0x0608F068
0x06092E78-0x06092E88
0x06093230-0x06093244
0x060935EE-0x06093602
0x06093674-0x0609367E
0x060936A0-0x060936A8
0x06093B14-0x06093B28
0x06093C14-0x06093C28
0x06093D14-0x06093D24
0x06093DF0-0x06093E04
0x06094460-0x06094468
0x0609448C-0x060944A0
0x06094548-0x0609458C
0x06096F34-0x06096F48
0x06094682-0x06094782 ; not detected by find-battle-text.py
